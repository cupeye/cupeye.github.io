<!doctype html>
<!--[if lt ie 7]>      <html class="lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if ie 7]>         <html class="lt-ie9 lt-ie8 ie7"> <![endif]-->
<!--[if ie 8]>         <html class="lt-ie9 ie8"> <![endif]-->
<!--[if gt ie 8]><!-->
<html class=""><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Spoqa Tech Blog | Celery를 이용한 긴 작업 처리</title>
  <link rel="canonical" href="https://spoqa.github.io/2012/05/29/distribute-task-with-celery.html">
  <meta property="og:title" content="Celery를 이용한 긴 작업 처리">
  <meta property="og:url" content="https://spoqa.github.io/2012/05/29/distribute-task-with-celery.html">
  <meta property="og:site_name" content="컵아이">
  
  
  <meta property="og:type" content="article">
  <meta property="og:description" content="처리 시간이 오래 걸리는 작업을 Celery를 통해 개선하는 방법을 알아봅니다.">
  
  
  <script>
    window.WebFontConfig = {
        custom: {
            families: ['spoqahansans:100,400,700'],
            urls: ['/css/spoqahansans.css']
        },
        timeout: 60000
    };
    (function(d) {
        var wf = d.createElement('script'), s = d.scripts[0];
        wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
        s.parentNode.insertBefore(wf, s);
    })(document);
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36136046-5', 'auto');
    ga('send', 'pageview');
  </script>
  <link rel="stylesheet" href="../../../css/styles.css">
  <link href="../../../atom.xml" type="application/atom+xml" rel="alternate" title="Spoqa 기술 블로그">
  <link rel="shortcut icon" href="../../../images/favicon.ico">
  <style type="text/css">
@media only screen and (max-width: 580px) {
  .btn-job {
    display: none;
  }
}
</style>
</head>
<body>
  <div class="wrapper">
    <div class="header">
      <div class="header-item">
        <div class="spoqa-logo-wrap">
          <a class="spoqa-logo" href="../../../"><img style="margin-top:-20px" src="../../../images/logo.png" alt="Spoqa logo"></a>
          <a class="blog-title" href="../../../">컵아이</a>
        </div>
        <div class="nav">
          <input type="checkbox" id="toggle">
          <label for="toggle" class="toggle" onclick></label>
          <ul class="menu">
            <li><a class="selected menu-about" href="../../../about.html">소개</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content">
      


<div class="post-author-info">
  
    <img class="portrait" src="../../../images/profile/longfin@spoqa.com.png" />
    <h1 class="post-title">Celery를 이용한 긴 작업 처리</h1>
    <span class="post-date">2012년 05월 29일</span>
    <span class="sep">|</span>
    <span class="author-name"><a href="mailto:longfin@spoqa.com">문성원</a></span>
  
</div>



  <div class="post"><p>스포카 개발팀 문성원입니다. 오늘은 <a href="http://celeryproject.org/">Celery</a>를 통해 오랜 시간이 걸리는 작업을 어떻게 개선하는지를 실례를 통해 알아보겠습니다.</p>

<h1 id="why-celery">Why Celery?</h1>

<p>지난주에 저희는 대량의 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a> 파일을 만들어서 관리자용 웹 페이지를 통해 내려받게끔 하는 기능을 추가해야 했습니다. 기존에 이미지파일을 압축해서 <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> 응답으로 내려주던 핸들러가 있었기에, 압축 루틴을 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a> 생성 루틴으로 바꿔치기만 하면 되는 아주 간단한 일이라고 생각했죠. (실제로 저희 팀의 <a href="https://github.com/akaz00">유병석</a>님이 <a href="http://www.reportlab.com/software/opensource/">reportlab</a>과 <a href="http://pybrary.net/pyPdf/">pyPdf</a>를 사용해서 멋지게 구현하셨죠.) 대강의 얼개는 이렇습니다.</p>

<script src="https://gist.github.com/2817829.js?file=src1.py"></script>

<p>그런데 문제가 생겼습니다. 이미지를 압축해서 내려주는 것에 비해서 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a>를 만드는 데는 훨씬 많은 시간이 필요했고, 이 때문에 사용하던 서비스(<a href="http://www.heroku.com/">Heroku</a>)에서 타임아웃을 내버렸습니다. 요청을 처리하는 핸들러가 직접 파일을 만들어서 줄 수 없게 돼버렸습니다.</p>

<p>다행히 저희는 이런 문제에 대한 일반적인 해결책을 잘 알고 있었습니다. 바로 별도의 작업자(Worker)를 두는 것이지요. 시간이 오래 걸리는 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a> 생성 루틴은 웹서버와 별개로 돌아가는 작업자에게 위임하고 요청을 처리하는 핸들러는 클라이언트(웹 브라우저)에게 바로 <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> 응답을 돌려줍니다. 생성된 파일은 <a href="http://aws.amazon.com/ko/s3/">Amazon S3</a>에 올려서 완료될 때 요청자가 내려받을 수 있게 만들면 됩니다.</p>

<p><img src="/images/2012-05-29/1.png" alt="list" /></p>

<p>그럼 이러한 작업자는 어떻게 구현할까요? 물론 시간과 여유가 있으신 분들은 바닥부터 만들어보시는 것도 좋은 경험이겠습니다만, 저희는 그럴 시간은 없었습니다. 그래서 선택한 것이 <a href="http://celeryproject.org/">Celery</a>입니다. <a href="https://spoqa.github.io/2011/12/24/about-spoqa-server-stack.html">지난 포스팅</a>에서 인용한 <a href="http://celeryproject.org/">Celery</a>에 관한 소개를 보시죠.</p>

<blockquote>
  <p><a href="http://celeryproject.org/">Celery</a>는 <a href="http://www.python.org/">Python</a>으로 작성된 <strong>비동기 작업 큐(Asynchronous task queue/job queue)</strong>입니다. 앞서 소개한 <strong>작업(Task)</strong>를 <strong>브로커(Broker, 스포카 서버는 <a href="http://redis.io/">Redis</a>를 사용)</strong>를 통해 전달하면 하나 이상의 <strong>워커(Worker)</strong>가 이를 처리하는 구조입니다. 포인트 적립-공유에 따른 분배처리, 포스팅 기능, 페이스북/트위터 공유등의 비동기 처리가 필요한 작업을 <a href="http://celeryproject.org/">Celery</a>에 위임하여 처리하고 있습니다.</p>
</blockquote>

<p>이 시나리오에서 작업(Task)에 해당하는 것은 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a> 생성 후 업로드입니다. 이 작업을 브로커(Broker)에 넣는 것은 요청을 받은 핸들러겠고요. 한번 고쳐진 소스를 보실까요?</p>

<script src="https://gist.github.com/2817829.js?file=src2.py"></script>

<h1 id="not-enuogh-memory">Not enuogh memory</h1>

<p>자 이제 응답이 지연될 일도 없으니 다 되었다고 생각한 저희는 테스트 환경에 배포해보았습니다. 그런데 테스트 중 이상한 에러 메시지가 떴습니다.</p>

<script src="https://gist.github.com/2817829.js?file=src3"></script>

<p><a href="https://devcenter.heroku.com/articles/error-codes#r14__memory_quota_exceeded">R14 Error에 대한 설명</a>을 살펴보니 아무래도 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a>를 만드는 도중 메모리가 부족해진 것 같네요. 실제로 <a href="http://www.heroku.com/">Heroku</a>의 <a href="https://devcenter.heroku.com/articles/dynos">Dyno</a>의 메모리 상한은 고작 512MB입니다. 하지만 우리가 만들 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a> 생산 작업은 1000 페이지당 약 1G 정도를 사용합니다.</p>

<p>이때 (<a href="http://jck.im">김재석</a>님이) 고안한 방법이 페이지를 나눠서 만드는 것입니다. <a href="https://devcenter.heroku.com/articles/dynos">Dyno</a>가 감당할 수 있을 만큼의 페이지 단위의 작업으로 쪼갠 뒤에 다시 큐에 넣어 각기 다른 작업자가 처리하게 하는 것이죠. (물론 <a href="https://devcenter.heroku.com/articles/dynos">Dyno</a>당 메모리 제한이기떄문에 <a href="http://celeryproject.org/">Celery</a>의 <a href="http://docs.celeryproject.org/en/latest/configuration.html#concurrency-settings">concurreny</a>를 고려해야 합니다.)</p>

<p><img src="/images/2012-05-29/2.png" alt="list" /></p>

<p>위의 개념을 적용한 코드를 함께 보시죠.</p>

<script src="https://gist.github.com/2817829.js?file=src4.py"></script>

<p>단 이 코드는 <a href="http://docs.celeryproject.org/en/latest/userguide/tasks.html#avoid-launching-synchronous-subtasks">교착상태(Deadloack)을 유발할 수 있습니다.</a> 작업 내에서 다른 작업 때문에 대기하고 있는 것은 큐라는 자원을 공유하는 이상 위험하기 때문이죠. 그래서 <a href="http://celeryproject.org/">Celery</a>는 이런 작업을 지원하기 위해 <a href="http://docs.celeryproject.org/en/latest/userguide/tasksets.html#subtasks">subtask</a>와 <a href="http://docs.celeryproject.org/en/latest/userguide/tasksets.html#chords">chord</a>라는 개념을 이용합니다. <a href="http://docs.celeryproject.org/en/latest/userguide/tasksets.html#chords">chord</a>는 <a href="http://docs.celeryproject.org/en/latest/userguide/tasksets.html#subtasks">subtask</a>들의 집합으로 묶여있는 작업들과, 그 작업들이 모두 끝났을 때 불릴 콜백(Callback)으로 구성됩니다. 이 <a href="http://docs.celeryproject.org/en/latest/userguide/tasksets.html#chords">chord</a>를 통해 원래 코드를 수정하면 다음과 같습니다.</p>

<script src="https://gist.github.com/2817829.js?file=src5.py"></script>

<h1 id="save-money">Save money</h1>

<p>이제 적절한 수의 작업자를 <a href="https://devcenter.heroku.com/articles/procfile">Procfile</a>에 설정해서 올리기만 하면 됩니다. 그런데 여기서 한 가지 아쉬운 점이 있습니다. 대량의 <a href="http://ko.wikipedia.org/wiki/PDF">PDF</a>를 처리하는 일은 그리 빈번히 발생하는 일이 아니므로 이를 기준으로 작업자 수를 설정하면 그만큼 노는 작업자가 늘게 됩니다. 작업자 <a href="https://devcenter.heroku.com/articles/dynos">Dyno</a> 수에 따라 요금이 부과되는 <a href="http://www.heroku.com/">Heroku</a>를 사용하고 있는 저희로서는 피하고 싶은 일이죠. 그래서 작업할 때만 작업자를 명시적으로 확장(Scale Up)하고, 작업이 끝나면 줄이는(Scale Down) 할 수 있는 방법이 필요했습니다. 이때 필요한 것이 바로 <a href="https://github.com/heroku/heroku.py">heroku.py</a>입니다. <a href="https://github.com/heroku/heroku.py">heroku.py</a>는 Heroku의 HTTP API를 <a href="http://www.python.org/">Python</a>에서 사용할 수 있도록 싸놓은 인터페이스입니다. 이러한 <a href="https://github.com/heroku/heroku.py">heroku.py</a>를 이용해서 작업자를 조정하는 메서드를 간단히 정의해볼까요?</p>

<script src="https://gist.github.com/2817829.js?file=src6.py"></script>

<p>마지막으로 이를 적용한 최종적인 코드는 다음과 같습니다.</p>

<script src="https://gist.github.com/2817829.js?file=src7.py"></script>

</div>


<div class="post-footer">
  <div class="back-btn"><a href="/">목록으로 돌아가기</a></div>
  <div class="fb-like" data-href="https://spoqa.github.io/2012/05/29/distribute-task-with-celery.html" data-layout="button_count" data-width="" data-share="false" data-show-faces="false"></div>
  <div class="fb-comments" data-href="https://spoqa.github.io/2012/05/29/distribute-task-with-celery.html" data-num-posts="5" data-width=""></div>
  <div id="fb-root"></div>
</div>
<script>
document.addEventListener("DOMContentLoaded", function(event) {
    $('.fb-like, .fb-comments').attr('data-width', "100%");
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/ko_KR/all.js#xfbml=1&appId=207542736008055";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
});
</script>
<style>
.hiring-banner {
  height: 320px;
  background-position-y: 80%;
}
.hiring-subtitle
{
  display: none;
}
.btn-job{
  margin-top: 4px;
}
@media only screen and (max-width: 360px) {
  .hiring-banner {
    height: 220px;
  }
}
}
</style>

    </div>
    <div class="push">
    </div>
    <div class="footer">
      <div id="info">
        <span>© <a href="http://cupeye.com/">컵아이</a> Inc. All rights reserved.</span>
        <span>Powered by <a href="https://pages.github.com/">GitHub Pages</a>.</span>
      </div>
    </div>
  </div>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="../../../js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(function() {
      $('.hiring-banner').bind("click", function() {
        location.href = '/jobs.html';
      });
      $('.toggle').bind("touchstart", function() {
        $('.menu').toggle();
      })
    });
  </script>
  <!-- Responsive layout polyfill for IE8 and lower -->
  <!--[if lte IE 8]>
  <script>
    var config = {
        mobileResponsiveBreakpoint: 650
    };
    $(window).on('resize', function(){
        if ($(window).width() <= config.mobileResponsiveBreakpoint) {
           !$(document.body).hasClass('res-mobile')) {
            $(document.body).addClass('res-mobile');
        } else {
            $(document.body).removeClass('res-mobile');
        }
    }).trigger('resize');
  </script>
  <![endif]-->
</body>
</html>
