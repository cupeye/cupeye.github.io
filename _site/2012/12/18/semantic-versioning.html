<!doctype html>
<!--[if lt ie 7]>      <html class="lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if ie 7]>         <html class="lt-ie9 lt-ie8 ie7"> <![endif]-->
<!--[if ie 8]>         <html class="lt-ie9 ie8"> <![endif]-->
<!--[if gt ie 8]><!-->
<html class=""><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Spoqa Tech Blog | Semantic Versioning 소개</title>
  <link rel="canonical" href="https://spoqa.github.io/2012/12/18/semantic-versioning.html">
  <meta property="og:title" content="Semantic Versioning 소개">
  <meta property="og:url" content="https://spoqa.github.io/2012/12/18/semantic-versioning.html">
  <meta property="og:site_name" content="컵아이">
  
  
  <meta property="og:type" content="article">
  <meta property="og:description" content="소프트웨어의 버전 명을 정하는 방법은 여러 가지가 있지만 명확한 기준 없이 지어질 때가 많습니다. 이번 글은 여러 경험을 종합하여 만들어진 Semantic Versioning 스펙을 소개합니다.">
  
  
  <script>
    window.WebFontConfig = {
        custom: {
            families: ['spoqahansans:100,400,700'],
            urls: ['/css/spoqahansans.css']
        },
        timeout: 60000
    };
    (function(d) {
        var wf = d.createElement('script'), s = d.scripts[0];
        wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
        s.parentNode.insertBefore(wf, s);
    })(document);
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36136046-5', 'auto');
    ga('send', 'pageview');
  </script>
  <link rel="stylesheet" href="../../../css/styles.css">
  <link href="../../../atom.xml" type="application/atom+xml" rel="alternate" title="Spoqa 기술 블로그">
  <link rel="shortcut icon" href="../../../images/favicon.ico">
  <style type="text/css">
@media only screen and (max-width: 580px) {
  .btn-job {
    display: none;
  }
}
</style>
</head>
<body>
  <div class="wrapper">
    <div class="header">
      <div class="header-item">
        <div class="spoqa-logo-wrap">
          <a class="spoqa-logo" href="../../../"><img style="margin-top:-20px" src="../../../images/logo.png" alt="Spoqa logo"></a>
          <a class="blog-title" href="../../../">컵아이</a>
        </div>
        <div class="nav">
          <input type="checkbox" id="toggle">
          <label for="toggle" class="toggle" onclick></label>
          <ul class="menu">
            <li><a class="selected menu-about" href="../../../about.html">소개</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content">
      


<div class="post-author-info">
  
    <img class="portrait" src="../../../images/profile/shinvee@spoqa.com.png" />
    <h1 class="post-title">Semantic Versioning 소개</h1>
    <span class="post-date">2012년 12월 18일</span>
    <span class="sep">|</span>
    <span class="author-name"><a href="mailto:shinvee@spoqa.com">JC Kim</a></span>
  
</div>



  <div class="post"><h2 id="versioning">Versioning?</h2>

<p>소프트웨어 개발 생태계는 수많은 사람들이 서로의 기술과 성과를 이어받아 오며 믿을 수 없는 수준의 협력 체제를 구축해오고 있습니다. 의존성은 이러한 협력체제에서 나오게 된 요소로, 다른 사람들이 만들어온 기능을 다시 만들 필요 없이 손쉽게 가져와서 재활용하는 방식으로 빠르게 소프트웨어를 만들 수 있게 되었습니다.</p>

<p>하지만 이렇게 여러 사람에게 이용되는 패키지가 새롭게 업데이트될 때, 생각보다 다양한 문제에 직면하게 되었습니다. 기능의 사용법을 바꾸어버리거나 동작 방식의 변경 같은 변화들은 그에 의존하는 다른 소프트웨어를 의도대로 동작하지 못하게 하므로, 새로운 변화와 기존의 것을 구분할 필요가 생겼습니다. 버전이라는 개념은 이러한 패키지의 변화를 구분하기 위해 사용하기 시작하였습니다</p>

<h2 id="semantic-versioning">Semantic Versioning?</h2>

<p>버전이라는 코드 형태의 구분방식은 많은 핵심 문제를 해결해주었지만, 아직 여러 과제가 남아있었습니다. 버전 명의 작성 방식에 관한 기준이 패키지마다 제각각 다른 것이 문제였습니다. 0.x와 1.x의 차이, 1.0.0 혹은 1.000. 선행 배포와 정식 버전의 구분 방법 등 모든 소프트웨어, 패키지는 저마다의 기준을 가지고 있었으며, 이는 어느 정도의 적당한 공통점이 있었지만, 그 점이 미묘하게 모두 차이가 있어 버전에 따른 의미 해석을 어렵게 하였습니다.</p>

<p><a href="http://semver.org/">Semantic Versioning</a>은 Github의 공동창업자인 <a href="http://tom.preston-werner.com/">Tom Preston-Werner</a>가 위의 문제를 해결하기 위해 기존의 현안을 모아 만든 제안입니다. 스펙 문서는 RFC 2119에 의해 규칙을 표기하여 의미적 엄격함을 높이고, 패키지 개발 생명주기에 발생할 수 있는 여러 상황을 포괄적으로 담아 일관성과 유연성을 균형 있게 갖추고 있습니다.</p>

<h2 id="section">규칙</h2>

<p>다음은 Semantic Versioning(v2.0.0-rc1)의 스펙을 한국어로 번역한 내용입니다.</p>

<ol>
  <li>
    <p>Semantic Versioning을 쓰는 소프트웨어는 반드시 공개 API를 정의해야 한다. 이 API는 코드 자체에 정의되어 있거나 명시적으로 문서화 되어있어야 한다. 이 과정은 포괄적이며 정확해야 한다.</p>
  </li>
  <li>
    <p>일반 버전 명은 반드시 X.Y.Z 형태를 보여야 하며 X, Y, Z는 음이 아닌 정수이다. X는 주요한 버전이며, Y는 작은 버전, Z는 패치버전이다. 각 요소는 1씩 차례로 증가해야 한다. 예: 1.9.0 -&gt; 1.10.0 -&gt; 1.11.0.</p>
  </li>
  <li>
    <p>주요 버전 숫자가 올라갈 때, 작은 버전 숫자와 패치 버전 숫자는 0으로 재설정되어야 한다. 작은 버전 숫자가 올라갈 때, 패치 버전 숫자는 0으로 재설정되어야 한다. 예: 1.1.3 -&gt; 2.0.0, 2.1.7 -&gt; 2.2.0</p>
  </li>
  <li>
    <p>버전 명이 주어진 패키지가 한번 공개되면, 해당 버전의 내용은 절대 수정되어선 안된다. 어떤 수정도 반드시 새로운 버전으로 공개되어야 한다.</p>
  </li>
  <li>
    <p>주요 버전 0 (0.y.z)은 초기 개발을 위한 것이다. 언제든 변경될 수 있다. 공개 API는 안전하지 않다고 여긴다.</p>
  </li>
  <li>
    <p>버전 1.0.0은 공개 API를 정의한다. 이 공개 이후의 버전 숫자가 바뀌는 방법은 공개 API와 변경 방법에 따라 결정된다.</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>패치 버전 Z (x.y.Z</td>
          <td>x &gt; 0)는 하위호환을 하지만 버그 수정이 있을 때 올라간다. 버그 수정은 내부적으로 잘못 처리되고 있는 것을 고치는 것을 의미한다.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>작은 버전 Y (x.Y.z</td>
          <td>x &gt; 0)는 새로운 기능이 추가되었지만 기존의 공개 API가 하위호환되고 있을 때 올라간다. 공개 API가 하나 이상 deprecated될 시에도 올라가야 한다. 부가적인 새 기능이나 개선이 내부 코드 (private code)에 있을 시에도 올릴 수 있다. 이는 패치 수준의 변화를 포함할 수 있으나, 작은 버전이 올라가면 패치 버전은 꼭 0이 되어야 한다.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>주요 버전 X (X.y.z</td>
          <td>X &gt; 0)는 하위호환되지 않는 변화가 추가될 때 반드시 올라가야 한다. 이는 패치 수준과 작은 수준의 변화를 포함할 수 있으나, 주요 버전이 올라가면 작은 버전과 패치 버전은 꼭 0이 되어야 한다.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>선행 배포 버전은 대시(-)와 점으로 나누어진 식별자들의 묶음을 패치 버전 뒤에 표시한다. 식별자들은 ASCII 영숫자와 대시로만 구성되어야 한다. [0-9A-Za-z-]. 선행 배포 버전은 연관된 일반 버전보다 낮은 우선순위를 가진다.</p>
  </li>
  <li>
    <p>개발 버전은 더하기(+)와 점으로 나누어진 식별자들의 묶음을 패치 버전 뒤에 표시한다. 식별자들은 ASCII 영숫자와 대시로만 구성되어야 한다. [0-9A-Za-z-]. 빌드 버전은 연관된 일반 버전보다 높은 우선순위를 가진다.</p>
  </li>
  <li>우선순위는 주요, 작은, 패치, 선행 배포, 빌드 식별자 내 숫자 순으로 계산되어야 한다. 주요, 작은, 패치 버전은 항상 숫자로 비교되어야 한다. 선행 배포와 빌드 버전의 우선순위는 반드시 각 점으로 나누어진 식별자들이 아래 규칙에 따라 비교되어야 한다: 1.  숫자로만 이루어진 식별자는 숫자로 비교 (2) 문자와 대시가 포함된 식별자는 ASCII 정렬 순서대로 비교. 숫자 식별자는 숫자가 아닌 식별자보다 낮은 우선순위를 가진다. 예: 1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0-rc.1+build.1 &lt; 1.0.0 &lt; 1.0.0+0.3.7 &lt; 1.3.7+build &lt; 1.3.7+build.2.b8f12d7 &lt; 1.3.7+build.11.e0f985a.</li>
</ol>

<h2 id="section-1">응용</h2>

<p>여러 오픈소스 프로젝트들이 이미 Semantic Versioning에 따라 버전 명을 표기하기 시작하였으며, 해당 규칙에 기반을 둔 버전 비교 라이브러리도 만들어지고 있습니다.</p>

<ul>
  <li>node.js: <a href="https://github.com/isaacs/node-semver">https://github.com/isaacs/node-semver</a></li>
  <li>PHP: <a href="https://github.com/GordonSchmidt/SemVer">https://github.com/GordonSchmidt/SemVer</a></li>
  <li>Python: <a href="https://github.com/k-bx/python-semver">https://github.com/k-bx/python-semver</a></li>
  <li>Ruby: <a href="https://github.com/iantruslove/SemverStringer">https://github.com/iantruslove/SemverStringer</a></li>
</ul>

<p><a href="https://github.com/substack/seaport">seaport</a>는 node.js 에서 서비스 클러스터들이  Semantic Versioning에 따라 버전 의존성을 가지게 설계할 수 있어 보다 안정적인 버전 협상이 가능하도록 하고 있습니다.</p>

<p><img src="https://a248.e.akamai.net/camo.github.com/39c1ea00e5dccec8ffc513066a5f9b89d8771f14/687474703a2f2f737562737461636b2e6e65742f696d616765732f736561706f72742e706e67" alt="seaport image" /></p>

<p>server.js:</p>

<pre><code>var seaport = require('seaport');
var ports = seaport.connect('localhost', 9090);
var http = require('http');

var server = http.createServer(function (req, res) {
    res.end('beep boop\r\n');
});

server.listen(ports.register('web@1.2.3'));
</code></pre>

<p>client.js:</p>

<pre><code>var seaport = require('seaport');
var ports = seaport.connect(9090);
var request = require('request');

ports.get('web@1.2.x', function (ps) {
    var u = 'http://' + ps[0].host + ':' + ps[0].port;
    request(u).pipe(process.stdout);
});
</code></pre>

<p>output:</p>

<pre><code>$ node server.js &amp;
[1] 6012
$ node client.js
beep boop
</code></pre>

<h2 id="section-2">마치며</h2>

<p>비록 작은 통일일지는 모르나, 버전 명을 작성하는 훌륭한 기준이 있다는 것은 장기적으로 개발 생태계를 더욱 빠르고 긴밀하게 협력하도록 도와줄 것이라 생각됩니다. 의미적 해석이 가능한 코드는 의존성 문제를 더 똑똑한 수준으로 자동화할 수 있기 때문이죠. 버전 명을 지으실 때 좋은 안내서가 되었으면 좋겠습니다.</p>

</div>


<div class="post-footer">
  <div class="back-btn"><a href="/">목록으로 돌아가기</a></div>
  <div class="fb-like" data-href="https://spoqa.github.io/2012/12/18/semantic-versioning.html" data-layout="button_count" data-width="" data-share="false" data-show-faces="false"></div>
  <div class="fb-comments" data-href="https://spoqa.github.io/2012/12/18/semantic-versioning.html" data-num-posts="5" data-width=""></div>
  <div id="fb-root"></div>
</div>
<script>
document.addEventListener("DOMContentLoaded", function(event) {
    $('.fb-like, .fb-comments').attr('data-width', "100%");
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/ko_KR/all.js#xfbml=1&appId=207542736008055";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
});
</script>
<style>
.hiring-banner {
  height: 320px;
  background-position-y: 80%;
}
.hiring-subtitle
{
  display: none;
}
.btn-job{
  margin-top: 4px;
}
@media only screen and (max-width: 360px) {
  .hiring-banner {
    height: 220px;
  }
}
}
</style>

    </div>
    <div class="push">
    </div>
    <div class="footer">
      <div id="info">
        <span>© <a href="http://cupeye.com/">컵아이</a> Inc. All rights reserved.</span>
        <span>Powered by <a href="https://pages.github.com/">GitHub Pages</a>.</span>
      </div>
    </div>
  </div>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="../../../js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(function() {
      $('.hiring-banner').bind("click", function() {
        location.href = '/jobs.html';
      });
      $('.toggle').bind("touchstart", function() {
        $('.menu').toggle();
      })
    });
  </script>
  <!-- Responsive layout polyfill for IE8 and lower -->
  <!--[if lte IE 8]>
  <script>
    var config = {
        mobileResponsiveBreakpoint: 650
    };
    $(window).on('resize', function(){
        if ($(window).width() <= config.mobileResponsiveBreakpoint) {
           !$(document.body).hasClass('res-mobile')) {
            $(document.body).addClass('res-mobile');
        } else {
            $(document.body).removeClass('res-mobile');
        }
    }).trigger('resize');
  </script>
  <![endif]-->
</body>
</html>
