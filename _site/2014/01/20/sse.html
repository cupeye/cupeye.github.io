<!doctype html>
<!--[if lt ie 7]>      <html class="lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if ie 7]>         <html class="lt-ie9 lt-ie8 ie7"> <![endif]-->
<!--[if ie 8]>         <html class="lt-ie9 ie8"> <![endif]-->
<!--[if gt ie 8]><!-->
<html class=""><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Spoqa Tech Blog | SSE를 이용한 실시간 웹앱</title>
  <link rel="canonical" href="https://spoqa.github.io/2014/01/20/sse.html">
  <meta property="og:title" content="SSE를 이용한 실시간 웹앱">
  <meta property="og:url" content="https://spoqa.github.io/2014/01/20/sse.html">
  <meta property="og:site_name" content="컵아이">
  
  
  <meta property="og:type" content="article">
  <meta property="og:description" content="HTML5의 표준안으로 권고되어있는 Server-Sent Events에 대해 알아보고 이를 이용하여 실시간 웹앱을 만들어 봅시다.">
  
  
  <script>
    window.WebFontConfig = {
        custom: {
            families: ['spoqahansans:100,400,700'],
            urls: ['/css/spoqahansans.css']
        },
        timeout: 60000
    };
    (function(d) {
        var wf = d.createElement('script'), s = d.scripts[0];
        wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
        s.parentNode.insertBefore(wf, s);
    })(document);
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36136046-5', 'auto');
    ga('send', 'pageview');
  </script>
  <link rel="stylesheet" href="../../../css/styles.css">
  <link href="../../../atom.xml" type="application/atom+xml" rel="alternate" title="Spoqa 기술 블로그">
  <link rel="shortcut icon" href="../../../images/favicon.ico">
  <style type="text/css">
@media only screen and (max-width: 580px) {
  .btn-job {
    display: none;
  }
}
</style>
</head>
<body>
  <div class="wrapper">
    <div class="header">
      <div class="header-item">
        <div class="spoqa-logo-wrap">
          <a class="spoqa-logo" href="../../../"><img style="margin-top:-20px" src="../../../images/logo.png" alt="Spoqa logo"></a>
          <a class="blog-title" href="../../../">컵아이</a>
        </div>
        <div class="nav">
          <input type="checkbox" id="toggle">
          <label for="toggle" class="toggle" onclick></label>
          <ul class="menu">
            <li><a class="selected menu-about" href="../../../about.html">소개</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content">
      


<div class="post-author-info">
  
    <img class="portrait" src="../../../images/profile/john@spoqa.com.png" />
    <h1 class="post-title">SSE를 이용한 실시간 웹앱</h1>
    <span class="post-date">2014년 01월 20일</span>
    <span class="sep">|</span>
    <span class="author-name"><a href="mailto:john@spoqa.com">송정우</a></span>
  
</div>



  <div class="post"><h2 id="server-sent-events">Server-Sent Events란?</h2>

<p>HTML5가 등장하기 전까지는 HTML에 서버 푸시를 위한 표준화된 기술이 없었기 때문에 웹에서 실시간 정보를 받아와야 할 때 외부 플러그인을 이용하거나 서버 푸시를 흉내 낸 Ajax 폴링(polling) 기법 등을 사용했습니다. 하지만 플러그인 종속적인 웹은 해당 플러그인을 설치해야 한다는 불편함이 있으며 폴링처럼 주기적인 요청을 통한 구현은 쓸모없는 요청의 발생으로 인한 대역폭의 낭비가 불가피하였습니다. HTML5의 <a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a>(이하 SSE)는 이러한 문제 없이 서버가 필요할 때마다 클라이언트에게 데이터를 줄 수 있게 해주는 서버 푸시 기술입니다.</p>

<h2 id="sse-">SSE의 장점</h2>

<p>SSE의 장점으로는 다음과 같은 것들이 있습니다.</p>

<ul>
  <li>전통적인 HTTP를 통해 통신하므로 다른 프로토콜이 필요가 없습니다.</li>
  <li>재접속 처리 같은 대부분의 저수준 처리가 자동으로 됩니다.</li>
  <li>표준 기술답게 IE를 제외한 브라우저 대부분을 지원합니다.</li>
  <li>HTML과 JavaScript만으로 구현할 수 있으므로 현재 지원되지 않는 브라우저(IE 포함)도 polyfill을 이용해 크로스 브라우징이 가능합니다. (여기서 polyfill이란 브라우저가 지원하지 않는 API를 플러그인이나 JavaScript 등으로 흉내 내 구현한 것을 뜻합니다. polyfill에 대한 자세한 설명은 <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">이 블로그 포스트</a>를 참조하시기 바랍니다.)</li>
</ul>

<p>사실 종합해보면 SSE의 모든 장점은 간편함으로 요약할 수 있습니다.</p>

<h2 id="section">적용 예</h2>

<p>위의 SSE의 장점에서 보듯이 SSE는 구현이 아주 간편합니다. 클라이언트는 서버로부터 스트림을 받아 <code>EventSource</code> 객체를 통해 서버가 푸시하는 데이터를 받아 처리하기만 하면 됩니다.</p>

<p>먼저 클라이언트 측의 코드입니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">es</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventSource</span><span class="p">(</span><span class="nx">stream_url</span><span class="p">);</span>

<span class="nx">es</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 이벤트 설정이안된 기본 데이터 처리</span>
<span class="p">};</span>
<span class="nx">es</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;myevent&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// &#39;myevent&#39; 이벤트의 데이터 처리</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span></code></pre></figure>

<p><code>EventSource</code> 객체의 속성은 다음과 같습니다.</p>

<dl>
  <dt><code>onmessage</code></dt>
  <dd>기본 메시지가 왔을 때 호출</dd>
  <dt><code>onopen</code></dt>
  <dd>접속이 맺어졌을 때 호출</dd>
  <dt><code>onerror</code></dt>
  <dd>오류 발생 시 호출</dd>
</dl>

<p><code>EventSource</code>의 <code>addEventListener()</code>를 사용하면 위 3개의 이벤트뿐만 아니라 따로 지정된 이벤트의 데이터도 받아 처리할 수 있습니다.</p>

<p>자 그럼 Flask와 <a href="http://www.redis.io/">Redis</a>를 이용한 서버 측의 코드를 볼까요? (예제는 Redis를 이용하였지만, <a href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish/Subscribe Model</a>이라면 다른 걸 쓰셔도 무방합니다.)</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">event_stream</span><span class="p">():</span>
    <span class="n">pub</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">pubsub</span><span class="p">()</span>
    <span class="n">pub</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="s">&#39;sse_example_channel&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">pub</span><span class="o">.</span><span class="n">listen</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;subscribe&#39;</span><span class="p">:</span>
            <span class="n">event</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">])</span>
            <span class="k">yield</span> <span class="s">u&#39;event: {0}</span><span class="se">\n</span><span class="s">data: {1}</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s">u&#39;data: {0}</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">])</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/stream&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_pushes</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">event_stream</span><span class="p">(),</span> <span class="n">mimetype</span><span class="o">=</span><span class="s">&quot;text/event-stream&quot;</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/post&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">publish_data</span><span class="p">():</span>
    <span class="c"># ...</span>
    <span class="n">redis</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="s">&#39;sse_example_channel&#39;</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="n">event</span><span class="p">,</span> <span class="n">data</span><span class="p">]))</span></code></pre></figure>

<p>응답의 형식을 <code>text/event-stream</code>으로 주고 이벤트 스트림을 걸어 놓습니다. <code>event_stream()</code>에서는 새로운 데이터가 들어오면 데이터를 형식에 맞추어 푸시하고 있습니다. SSE에서의 데이터 형식은 2개의 개행으로 구분됩니다.</p>

<pre><code>data: This is the first message.

data: This is the second message, it
data: has two lines.

event: myevent
data: This is the third message with a separated event.
</code></pre>

<h2 id="websocket-server-sent-events">WebSocket과 Server-Sent Events</h2>

<p>완전한 양방향 통신을 지원하는 <a href="http://www.w3.org/TR/websockets/">WebSocket</a>이 SSE보다 더 매력적으로 보일 수 있습니다. WebSocket 또한 표준 기술인데다 양방향 통신이고 브라우저 지원 범위도 더 넓습니다.</p>

<p>그렇지만 WebSocket이 SSE보다 항상 더 좋은 것은 아닙니다. 채팅이나 게임 같이 사용자가 서버의 데이터에 즉각 반응해야 하는 경우라면 WebSocket을 사용하는 것이 더 효율적이겠지만 많은 경우 클라이언트 측에서의 반응은 필요가 없습니다. 주식차트, 뉴스피드, 푸시 노티피케이션 등이 대표적인 예입니다.</p>

<p>브라우저 지원 부분에서도 SSE가 더 유리한 측면이 있습니다. WebSocket은 브라우저가 지원하지 않을 때에는 서버 측에서 이에 대응하는 fallback 프로토콜을 별도로 구현해야만 합니다. 반면, SSE는 클라이언트 기술이기 때문에 서버 측 구현을 더 복잡하게 하지 않고도 브라우저가 JavaScript만 지원한다면 polyfill을 이용하여 구현이 가능합니다.</p>

<p>따라서 상황에 따라 복잡한 WebSocket을 이용하는 것보다는 간단한 SSE를 통해 구현하는 것이 여러 가지로 유리할 수 있습니다.</p>

</div>


<div class="post-footer">
  <div class="back-btn"><a href="/">목록으로 돌아가기</a></div>
  <div class="fb-like" data-href="https://spoqa.github.io/2014/01/20/sse.html" data-layout="button_count" data-width="" data-share="false" data-show-faces="false"></div>
  <div class="fb-comments" data-href="https://spoqa.github.io/2014/01/20/sse.html" data-num-posts="5" data-width=""></div>
  <div id="fb-root"></div>
</div>
<script>
document.addEventListener("DOMContentLoaded", function(event) {
    $('.fb-like, .fb-comments').attr('data-width', "100%");
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/ko_KR/all.js#xfbml=1&appId=207542736008055";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
});
</script>
<style>
.hiring-banner {
  height: 320px;
  background-position-y: 80%;
}
.hiring-subtitle
{
  display: none;
}
.btn-job{
  margin-top: 4px;
}
@media only screen and (max-width: 360px) {
  .hiring-banner {
    height: 220px;
  }
}
}
</style>

    </div>
    <div class="push">
    </div>
    <div class="footer">
      <div id="info">
        <span>© <a href="http://cupeye.com/">컵아이</a> Inc. All rights reserved.</span>
        <span>Powered by <a href="https://pages.github.com/">GitHub Pages</a>.</span>
      </div>
    </div>
  </div>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="../../../js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(function() {
      $('.hiring-banner').bind("click", function() {
        location.href = '/jobs.html';
      });
      $('.toggle').bind("touchstart", function() {
        $('.menu').toggle();
      })
    });
  </script>
  <!-- Responsive layout polyfill for IE8 and lower -->
  <!--[if lte IE 8]>
  <script>
    var config = {
        mobileResponsiveBreakpoint: 650
    };
    $(window).on('resize', function(){
        if ($(window).width() <= config.mobileResponsiveBreakpoint) {
           !$(document.body).hasClass('res-mobile')) {
            $(document.body).addClass('res-mobile');
        } else {
            $(document.body).removeClass('res-mobile');
        }
    }).trigger('resize');
  </script>
  <![endif]-->
</body>
</html>
